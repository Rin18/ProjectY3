from music21 import *
import numpy as np
import random

#Function to parse through midi files
def parse_midi(file):
    print("Working on :",file)

    notes = []
    rest = False
    notes_to_parse = None
    midi = converter.parse(file)

    #Partition instruments
    instruments = instrument.partitionByInstrument(midi)

    for part in  instruments.parts:
        #Currently only piano
        if 'Piano' in str(part):
            notes_to_parse = part.recurse()

            for element in notes_to_parse:
                if isinstance(element, note.Note):
                    notes.append(str(element.pitch))
                #elif isinstance(element, chord.Chord):
                #    notes.append('.'.join(str(n) for n in element.normalOrder))
                elif isinstance(element, note.Rest) and rest:
                    notes.append("rest")
    
    #Return array with notes
    return np.array(notes)
    #return notes

#Parse notes in one midi file
result = parse_midi("for_elise_by_beethoven.mid")
#print("Result: \n", result)

#Trying to work out note to int and int to note
unique_notes = list(set(result))
n_notes = len(unique_notes)
#print("Notes nr: \n", n_notes)


"""
# MAP INTEGER -> NOTE AND NOTE -> INTEGER
note_to_int = dict((note, number) for number, note in enumerate(unique_notes))
#print("note_to_int: \n", note_to_int)

#int_to_note = dict((number, note_) for number, note_ in enumerate(unique_notes)) 
#predicted_notes = [int_to_note[i] for i in predictions]

def generate_notes(pitchnames, n_vocab):
    # pick a random sequence from the input as a starting point for the prediction

    int_to_note = dict((number, note) for number, note in enumerate(pitchnames))

    predicted_notes = []

    for note_index in range(100):
        index = random.randrange(0, n_vocab-1, 1)
        result = int_to_note[index]
        predicted_notes.append(result)

    return predicted_notes

predicted_notes = generate_notes(unique_notes, n_notes)
print("Predicted notes: \n", predicted_notes)

"""

#Take a note and add one tone to it
"""
note = result[10]
#print("Note: \n", note)
note2 = pitch.Pitch(note)
print("Note: \n", note2)
temp_note = note2.transpose(2)
print("Note: \n", temp_note)
"""


#Increasing notes by semitone

#Incease notes by a tone and add them to array
increased_notes = []
for notes in result:
    increased_note = (pitch.Pitch(notes).transpose(2))
    increased_notes.append(str(increased_note))

print("Increased notes: \n", increased_notes)



#TURN RESULTS BACK INTO MIDI

#Need to fix this
#Create midi file of given notes
def output_midi(prediction_output):
   
    offset = 0
    output_notes = []

    # create note and chord objects based on the values generated by the model
    for pattern in prediction_output:
        # pattern is a chord
        """if ('.' in pattern) or pattern.isdigit():
            notes_in_chord = pattern.split('.')
            notes = []
            for current_note in notes_in_chord:
                
                cn=int(current_note)
                new_note = note.Note(cn)
                new_note.storedInstrument = instrument.Piano()
                notes.append(new_note)
                
            new_chord = chord.Chord(notes)
            new_chord.offset = offset
            output_notes.append(new_chord)
            
        # pattern is a note
        else:"""
        
        new_note = note.Note(pattern)
        new_note.offset = offset
        new_note.storedInstrument = instrument.Piano()
        output_notes.append(new_note)

        # increase offset each iteration so that notes do not stack
        offset += 0.25
    midi_stream = stream.Stream(output_notes)
    midi_stream.write('midi', fp='result_music.mid')

output_midi(result)