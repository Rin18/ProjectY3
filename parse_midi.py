#This file contains various functions with recurrent use

from music21 import *
import numpy as np

# PARSE_MIDI
# Function to parse through midi files
def parse_midi(file):
    print("Working on :",file)
    notes = []
    rest = False
    notes_to_parse = None
    midi = converter.parse(file)

    # Partition instruments
    instruments = instrument.partitionByInstrument(midi)

    for part in  instruments.parts:
        # Currently only piano
        if 'Piano' in str(part):
            notes_to_parse = part.recurse()

            for element in notes_to_parse:
                # Note
                if isinstance(element, note.Note):
                    notes.append(str(element.pitch))
                # Chord, currently not in use
                #elif isinstance(element, chord.Chord):
                #    notes.append('.'.join(str(n) for n in element.normalOrder))
                # Rest
                elif isinstance(element, note.Rest) and rest:
                    notes.append("rest")
    
    # Return array with notes
    return np.array(notes)
    #return notes

# ADD_SEMITONES
# Increase notes in note_array by nr_semitones
def add_semitones(note_array, nr_semitones):
    increased_notes = []
    for notes in note_array:
        increased_note = (pitch.Pitch(notes).transpose(nr_semitones))
        increased_notes.append(str(increased_note))

    return increased_notes


# OUTPUT_MIDI
# Create midi file of given notes array
def output_midi(prediction_output, file_name):
    print("Converting to MIDI \n")
    offset = 0
    output_notes = []

    # create note and chord objects based on the values generated by the model
    for pattern in prediction_output:
        # Chord pattern, currently not in use
        """if ('.' in pattern) or pattern.isdigit():
            notes_in_chord = pattern.split('.')
            notes = []
            for current_note in notes_in_chord:
                
                cn=int(current_note)
                new_note = note.Note(cn)
                new_note.storedInstrument = instrument.Piano()
                notes.append(new_note)
                
            new_chord = chord.Chord(notes)
            new_chord.offset = offset
            output_notes.append(new_chord)
            
        # Note pattern
        else:"""
        # Currently only going over notes

        new_note = note.Note(pattern)
        new_note.offset = offset
        new_note.storedInstrument = instrument.Piano()
        output_notes.append(new_note)

        # Make sure notes don't stack by increasing offset
        offset += 0.5
    midi_stream = stream.Stream(output_notes)
    midi_stream.write('midi', fp=("results/"+file_name + '_result.mid'))
